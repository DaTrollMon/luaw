Luaw stands for Lua Webserver. In a happy coincidence it also matches abbreviation for an air traffic controller command (line up and wait) that closely resembles the way it handles multiple requests using event loop :)

Luaw is an event driven, non blocking IO based server inspired by node.js. It uses
node.js's excellent libuv library to do non-blocking IO but it takes advantage of Lua's first class coroutine support to avoid callback hell. This makes writing async IO code exactly same as normal sequential code while all the heavy-lifting of application state management usually associated with event driven IO is transparently handled by Lua's excellent coroutine support.

It includes,
1. Full HTTP 1.1 support with persistent/keep-alive connections and HTTP pipelining with configurable connect and read timeouts.
2. Two ways to read and parse incoming HTTP requests,
	1. Reading whole request in memory and then parsing it which is suitable for majority of applications.
    2. Reading request stream and parsing it as it arrives in parts to minimize latency as well as server memory footprint for high traffic, high performance applications like HTTP proxies or HTTP load balancers. 
3. Similarly on the output side it supports,
	1. Buffering entire content in memory before writing it out to client with the correct "Content-Length" header.
    2. Streaming output continuously as it is generated using HTTP 1.1 chunked encoding to keep server memory pressure minimum.
4. Fully asynchronous DNS and HTTP clients for making remote HTTP calls from server
5. [Sinatra](http://www.sinatrarb.com/) like web application framework that supports mapping URLs to routes. it can be used to map URLs to REST resources in a fashion similar to Sun Jersey with full support for path parameters.
6. [MessagePack](http://msgpack.org/) like library to efficiently serialize/deserialize arbitrarily complex data into compact and portable binary format for remote web service calls.
7. Complete templating engine for server side dynamic content generation that compiles templates written in Luaw DSL down to Lua bytecode on the fly. The engine uses streaming output with chunked encoding described above to eliminate need for huge memory buffers to cache output generated by templates. 
8. Log4j like logging framework with configurable log levels, log file size limits and automatic log rotation with syslog integration out of the box.


##How To Build
Luaw use [luarocks](http://www.luarocks.org) as its build system. You need following artifacts to build it:
1. Lua 5.2+. You can either download a binary distribution from [here](http://luadist.org/) or [build it yourself from source](http://www.lua.org/download.html)
2. Luarocks. Get it from [here](http://www.luarocks.org/en/Download)
3. Libuv. build instructions [here](https://github.com/joyent/libuv#build-instructions). Make sure libuv.a is in your system library path and uv.h is installed in your system's include path.

Once you have all the three from above, change to ~/luaw directory on your system and run
> sudo luarocks make

##How to run
1. Export environmental variable [LUA_PATH](http://www.lua.org/pil/8.1.html) - either using start up file like .bash_profile or from the command line - that includes ~/luaw/lib and current directory like this:
> export LUA_PATH="?;?.lua;/home/John/GitHub/luaw/lib/?;/home/John/GitHub/luaw/lib/?.lua"

Lua uses [LUA_PATH](http://www.lua.org/pil/8.1.html) to locate Lua scripts and modules to run
2. Change to ~/luaw/sample directory on your system and create directory "log" there 
3. Run
> lua ../lib/server.lua server.cfg

At this point Luaw should be running and listening on port 8080. You can test sample REST webapp deployed in it by pointing your browser to http://localhost:8080/myapp/address/100/Main_Street/Sunnyvale/CA/94086.

Happy hacking!











