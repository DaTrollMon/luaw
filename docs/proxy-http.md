#13. Advanced Topic I - Using custom HTTP handler for stream parsing

One of the strength of Luaw is its extreme programmability. It exposes lot more internal APIs/hooks/networking machinery to developer than a typical HTTP server does. This makes it possible to use Luaw over a wide range of applications. Luaw developers can pick and choose what level of details they want to concern themselves with depending upon their individual applications' needs.

On one end of a spectrum is a typical CRUD web application or a REST service which can be developed rapidly using out of box Luaw components of REST resource handler functions and Luaw template views. In this case developers need not concern themselves with nitty-gritties of low level networking and HTTP protocal parsing. They let Luaw do all this heavy lifting for them and just use pluggable points of Luaw's built-in MVC web application framework to hook their application code into Luaw. Most app servers and web application frameworks focus exclusively at this end of spectrum - and for a good reason. Most of apps - by numbers - lie towards this end of spectrum.

But there are other class of applications like HTTP proxy servers or HTTP caches that need to be able to server very high volume of traffic while utilizing as few resources per request as possible. Typically these applications need access to much lower level of networking and HTTP protocol parsing APIs to squeeze out the last bit of performance. Traditionally these applications are coded from scratch using straight C or C++ instead of using some pre-existing app server container because most app servers do not provide unfettered access to these low level APIs. Downside of such from scratch, dedicated code servers is that they are generally not as programmable by their end users as compared to popular general app servers like Tomcat etc. For example, a web proxy server may benefit from the ability to let its end users specify exact logic for routing different proxy requests to backend servers using a user supplied function of script. However many proxy server support only a fixed set of configuration directives to control how requests are routed. For more complicated routing decisions, regular expressions matching request path and/or HTTP headers are often employed. This is less than ideal in many cases but since these high performance servers are not general purpose application servers they typically don't have the ability to run user supplied code to control routing.

Luaw aspires to address this end of spectrum too. Being general purpose application server it already has ability to install and run user supplied code as request or resource handlers. To address the issue of low level access for maximum performance it exposes it's internal networking and HTTP processing machinery in a separate low level API layer which developers can optionally hook into to write high performance servers

To show how these low level APIs can be used, we will develop a toy HTTP reverse proxy server in this section. A typical reverse proxy server accepts a HTTP request from a client, inspects its contents and then forwards it to one of many backend HTTP servers it is fronting depending upon the results of the request content inspection. On the return path it receives the response generated by the backend server and forwards it to the connected client.
```
+------+ ----HTTP request---> +-------------+ --- Proxy HTTP request ---> +-------+
|Client|                      |Reverse Proxy|                             |Backend|
+------+ <---HTTP response--- +-------------+ <-- Proxy HTTP response --- +-------+
```

Now, you can program this proxy server without using any of the low level APIs made available by Luaw. You could, in theory, register a single resource handler that all clients send their request to. This resource handler will receive request object in the handler function which it can inspect to decide where the backend request should go. Then it can use Luaw's async HTTP client to connect to that backend server and send the client request to it. The HTTP client will return the response generated by the  backend server which can then be proxied back to the original client connected to the proxy server using the response object passed into the handler function.

This kind of simple proxy server will indeed be sufficient for low to moderate, even somewhat high level of incoming traffic. Remember, all network operation as well as HTTP parsing in Luaw is async (non-blocking) by default so even though we are not using any special low level APIs yet this implementation is still likely to scale better out of the box than thread based solutions that assign individual OS threads per incoming request.

But for truly insane amount of traffic we could further fine tune this handler using the low level Luaw APIs. By default Luaw will buffer incoming request till it has received it in its entirety and then parsed it completely before calling the resource handler function. This way when resource handler is called all the request parameters and headers are already parsed and ready to be accessed by the resource handler function which makes code of the resource handler very easy and straight forward to write. This is the right - and hence Luaw's default - choice most of the time. But in case of a reverse proxy server, we may be able to keep our memory footprint low and latency minimum if we start parsing HTTP request in a streaming fashion - i.e. start parsing it as soon as it starts coming in and calling a specially written request handler with bits and pieces of request that we have parsed so far.

Same thing applies to Luaw's async HTTP client API. Typically you use client:execute(request) where you pass in fully constructed request object to Luaw HTTP client's execute() method. This methods writes the whole request to target server, buffers response returned by the server and returns to caller only when the entire response is received and parsed completely. This makes caller's code straightforward but this is not the only way to use Luaw HTTP client. With more effort you could use Luaw HTTP client's lower level APIs to stream HTTP request to target server as it is received from the original client whose request we are proxying. Similarly on the return path the HTTP client does not necessarily have to wait till it has received whole response from the backend server. Here again we can receive and parse backend server's response in a streaming fashion, writing bits of response back to the original connected client as the bits trickle in from the backend server. This type of streaming request and response parsing improves overall latency of the proxying as their is no waiting around for request and response to arrive in full while also improving memory footprint of the proxy server at the same time because large buffers are no longer needed to hold entire request and response.

Finally, There is a small wrinkle in the streaming flow described above. Most proxy server logic involves being able to inspect incoming client request for its HTTP method (GET vs POST for example), its HTTP headers and its PATH at minimum to make routing decisions regarding which backend server to route this request to. This means when we call our proxy resource handler it should at least be able to access HTTP method, headers and path of the request to run its logic. So on the incoming path we still have to wait till the incoming requests headers are all parsed and request body begins before handing the control off to resource handler logic. From that point onwards request/response processing - including the body of the incoming request - can proceed in a true streaming fashion.

Putting all this rambling together, this is how our processing pipeline finally looks:

1. Accept incoming request using specially written proxy resource handler. Buffer and parse the incoming request in memory till all HTTP headers are received.
2. Call the actual proxying code with parsed HTTP method, headers and path for the incoming request. Proxying logic can inspect these pieces of information - possibly passing them into user supplied routing function/script - and decides which backend server to proxy this request to. It then uses Luaw async HTTP client to connect to that backend server.
3. On successfully connecting to the backend server, proxy function writes whatever HTTP header it wants to send to the backend server - which are normally some subset of HTTP headers copied from original client request + some custom headers to identify proxy - on the connection in streaming fashion.
4. Once headers are sent to the backend server the proxy logic loops in following steps
    1. Read whatever part of request is available from the connecetd client.
    2. Parse it in streaming fashion to detect if the client HTTP request has ended with this part
    3. Write it to the backend server in streaming fashion using Luaw HTTP client
    4. Read whatever part of the response is returned by backend server
    5. Parse it in streaming fashion to detect if server has finished generating response with this part
    6. Write the response part read back to the client.
All these steps proceed in lock-step, hand in hand. The request sent by the client is streamed continuously to the backend server and response generated by the backend server is streamed back to the client simultaneously without any unnecessary intermediate buffering in proxy server.
5. Finally when the end of client's HTTP request is detected by the Luaw streaming HTTP parser, the "end" is written to the backend server which causes the backend server to end its response to the proxied request. This end of response is propagated back to the client which is now free to disconnect from the proxy server.

Phew, that was a very long read. Surprisingly actual code to achieve all this is not nearly that long. (Which is why writing good documentation is hard:)

Here is the code with inline comments explaining what's going on. Our toy proxy server uses a protocol where by client sends the backend host and URL it wants to connect through the proxy server in its HTTP request's "proxy-host" and "proxy-url" headers respectively. If any of these headers are missing our proxy server responds with 400 error. It also proxies only HTTP GET requests but its easy to see how it can be modified to proxy other HTTP methods too.

```lua
--[[
	Since we want to hook up into low level APIs of Luaw server, we register a specialized resource handler with Luaw. Luaw allows you to replace it's default MVC/REST request handler with your own custom HTTP request handler implementation.
	To override the default HTTP request handler just set Luaw object's request_handler property to your custom Lua function. This function is passed in a low level connection object for each incoming request instead of the normal request and response objects. The function is called on its own separate Luaw coroutine for each HTTP request so you don't have to worry about multithreaded access to same state inside the function.
]]

    Luaw.request_handler = function(conn)
        local status, req = pcall(Luaw.newServerHttpRequest, conn)
        -- handle persistent connection timeout gracefully
        if not status then
            return false
        end

        local resp = Luaw.newServerHttpResponse(conn)

        --[[ Use streaming read and parse HTTP request function to parse incoming HTTP request as it comes in bits and pieces. It returns two flags: whether it has done parsing headers and whether it has reached end of the request. We loop waiting till it says it is done pasring headers for the reasons explained above ]]

        local headersDone, mesgDone = false, false
        while (not headersDone) do
            headersDone, mesgDone = req:readAndParse()
        end

        --[[ Done parsing headers, can safely read their values here ]]
        local proxyHost = req.headers['proxy-host']
        local proxyURL = req.headers['proxy-url']

        if ((proxyHost)and(proxyURL)) then
            --[[ Create a new Luaw async HTTP client request ]]
            local proxyReq = Luaw.newClientHttpRequest()
            proxyReq.hostName = proxyHost
            proxyReq.url = proxyURL
            proxyReq.method = 'GET'
            proxyReq.headers = { Host = proxyHost }

            --[[ Use HTTP client's low level API - connect() followed by readStreaming() - instead of the usual execute() ]]
            local proxyResp = proxyReq:connect()
            proxyReq:flush()

            --[[Parse response returned by the backend server in streaming fashion, looping till all the response headers are parsed ]]
            local proxyHeadersDone, proxyMesgDone, prxoyBody = false, false, nil
            while not proxyHeadersDone do
                proxyHeadersDone, proxyMesgDone, prxoyBody = proxyResp:readStreaming()
            end

            --[[Send the HTTP status returned by the backend server back to the client, along with other response headers.]]
            resp:setStatus(proxyResp.status)
            local proxyHeaders = proxyResp.headers
            for k,v in pairs(proxyHeaders) do
                if (k ~= 'Transfer-Encoding') then
                    resp:addHeader(k,v)
                end
            end

            --[[ Here we set the response we are sending back to the original client in chunked transfer encoding mode so that we don't have to buffer entire body of the response returned by the backend server ]]
            resp:startStreaming()


            --[[finally here we read response body - response headers are already parsed and send back to client by this time - from back end server as it arrives in bits and pieces and echo it back to the original client in lock step, till the response is completely consumed ]]
            while true do
                if prxoyBody then
                    resp:appendBody(prxoyBody)
                end
                if proxyMesgDone then
                    break
                end
                proxyHeadersDone, proxyMesgDone, prxoyBody = proxyResp:readStreaming()
            end

        else
            resp:setStatus(400)
            resp:appendBody("Headers proxy-host and proxy-url must be present")
        end

        --[[ final resource cleanup ]]
        resp:flush()
        proxyResp:close()
        req:close()
        resp:close()
    end
```

The last bit of puzzle remaining is how do we actually load this new, shiny custom HTTP handler of ours into Luaw server? To this we use a simple trick that is quite flexible and powerful in practice. So far we have been starting our Luaw server with following command in luaw_roo_dir:
```
./bin/luaw_server ./conf/server.cfg
```
Where `server.cfg` is a Luaw server configuration file. In reality `luaw_server` binary will read and execute any number of Lua script files specified as series of command line arguments. The very first one is assumed to be server configuration file and is mandatory. Any number - and any kind - of Lua script files can follow the configuration file and are executed by `luaw_server` in the same order as they are specified on the start up commmand line using the same Lua VM and global environment. We can use this handy trick to load any functions we want into Luaw as well as hook up into Luaw's internal machinery using any of the public hook up points that Luaw advertises.

So for our case, just create a file called proxy-handler.lua under `luaw_roo_dir/bin` folder and put the above code in it. Then from your command prompt run Luaw like this:

    ./bin/luaw_server ./conf/server.cfg ./bin/proxy-handler.lua

`luaw_server` will run your proxy-handler.lua after it has initialized itself. The script in proxy-handler.lua then takes care of replacing Luaw's default HTTP request handler with the custom one by assigning the custom handler function to `Luaw.request_handler` property.

Now test your shiny new proxy server by running following tests:

## Test 1 - Missing required headers

    $ curl -v http://127.0.0.1:7001/
    *   Trying 127.0.0.1...
    * Connected to 127.0.0.1 (127.0.0.1) port 7001 (#0)
    > GET / HTTP/1.1
    > User-Agent: curl/7.37.1
    > Host: 127.0.0.1:7001
    > Accept: */*
    >
    < HTTP/1.1 400 Bad Request
    < Content-Length: 50
    <
    Headers proxy-host and proxy-url must be present

## Test 2 - With correct headers
    $ curl -v -H"proxy-host: www.google.com" -H"proxy-url: /" http://127.0.0.1:7001/
    *   Trying 127.0.0.1...
    * Connected to 127.0.0.1 (127.0.0.1) port 7001 (#0)
    > GET / HTTP/1.1
    > User-Agent: curl/7.37.1
    > Host: 127.0.0.1:7001
    > Accept: */*
    > proxy-host: www.google.com
    > proxy-url: /
    >
    < HTTP/1.1 200 OK
    < Content-Type: text/html; charset=ISO-8859-1
    < Transfer-Encoding: chunked
    * Server gws is not blacklisted
    < Server: gws

    (.. followed by the body of the home page at www.google.com)
